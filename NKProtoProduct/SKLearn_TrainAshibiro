#! python3
# -*- coding:utf-8 -*-
import numpy as np
import joblib
import sys
from PIL import Image
from pathlib import Path
from sklearn.neural_network import MLPClassifier
import matplotlib.pyplot as plt

class SKLearn_InsectClassifier():
    __imgTrain__ = None
    __imgTargetClass__ = None
    __imgTargetClassName__ = set()
    __imgTest__ = None
    __resizeX__ = 100
    __resizeY__ = 100
    model = None
    __runMode__ = ['TRAIN','PREDICT','BOTH']
    
    def __init__(self):
        pass
    
    def load_images(self,imageDirStr):
        loadResult = None
        
        if imageDirStr is not None:
            imageDirPath = Path(imageDirStr)
            if imageDirPath.exists() and imageDirPath.is_dir():
                imgTrain = None
                imgTargetClass = None
                print(imageDirPath.glob('**/*'))
                for iterItem in imageDirPath.glob('**/*'):
                    if iterItem.suffix in ('.jpeg', '.jpg', '.png'):
                        img = Image.open(str(iterItem))
                        imgAfResize = img.resize( (self.__resizeX__, self.__resizeY__) )
                        data = np.asarray(imgAfResize,dtype=int)
                        className = iterItem.parts[-2:-1]
                        self.__imgTargetClassName__.add(className[0])
                        if imgTrain is None:
                            imgTrain = np.array([data.flatten()])
                            imgTargetClass = np.array([className])
                        else:
                            imgTrain = np.append(imgTrain, np.array([data.flatten()]), axis=0)
                            imgTargetClass = np.append(imgTargetClass, className)
                loadResult = [imgTrain,imgTargetClass]
                
        return loadResult
        
    def training(self,imageDirStr):
        self.__imgTrain__, self.__imgTargetClass__ = self.load_images(imageDirStr)
        self.model = MLPClassifier(hidden_layer_sizes=(200,200,200), max_iter=50000, tol=0.000001, random_state=1)
        flattenData = self.__imgTrain__
        flattenTarget = self.__imgTargetClass__
        self.model.fit(flattenData, flattenTarget)
        
    # @args savePathStr None    :no save train result.
    #                   not None:save train result to indicated directory.
    def save_model(self,savePathStr=None):
        if savePathStr is not None:
            saveModelDir = Path(savePathStr)
            if saveModelDir.exists() and saveModelDir.is_dir():
                joblib.dump(self.model, savePathStr + 'MLPClassifier_Insects.model')
                
    # @args loadPathStr None    :load model from current directory.
    #                   not None:load model from indicated directory.
    def load_model(self,loadPathStr=None):
        if loadPathStr is not None:
            loadModelPath = Path(loadPathStr)
            if loadModelPath.exists():
                self.model = joblib.load(loadPathStr + 'MLPClassifier_Insects.model')
                
    # @args testPathStr None    :use already loaded testdata.
    #                   not None:use testdata from indicated path.
    def predict(self,testPathStr=None):
        if testPathStr is not None:
            testPath = Path(testPathStr)
            loadData = self.load_images(testPathStr)
            self.__imgTest__ = loadData[0]
            
        if self.__imgTest__ is not None:
            flattenData = self.__imgTest__
            result = self.model.predict(flattenData)
            return result
                
    def plotTrainResult(self):
        if isinstance(self.model, MLPClassifier):
            plt.title('result predict')
            plt.xlabel('time step')
            plt.ylabel('loss')
            plt.ylim(0,max(self.model.loss_curve_))
            plt.plot(self.model.loss_curve_)
            plt.show()
            
if __name__ == '__main__' :
    trainInsect = SKLearn_InsectClassifier()
    if sys.argv[1] == 'TRAIN':
        trainInsect.training(sys.argv[2] + 'expand')
        trainInsect.plotTrainResult()
        trainInsect.save_model(sys.argv[2])
    
    if sys.argv[1] == 'PREDICT':
        trainInsect.load_model(sys.argv[2])
        result = trainInsect.predict(sys.argv[2] + 'test')
        print(result)
        
